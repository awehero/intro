<!DOCTYPE html>
<html>
<head>
  <title>URL to JS Map Converter</title>
</head>
<body>
  <label for="query">Enter the full mapfile here:</label>
<input type="text" id="query" placeholder="Script goes here...">
  <button onclick="extractStartData()">Go!</button>
  <div>Made by awehero54</div>
<div id="result"></div>

<script>
function extractStartData() {
    // Get the mapfile string from an HTML element with id 'query'
    let mapfile = document.getElementById("query").value;

    // Separate schemas for each object type
    const schemas = {
        "a.p": ["type", "position", "rotation", "size", "color", "friction", "air", "bounce", "jump", "drift", "mass", "killer"],
        "a.c": ["type", "position", "color"],
        "a.e": ["type", "position"],
        "a.y": ["type", "position", "rotation", "size", "color", "bounce", "mass", "friction", "air", "topr", "killer"],
        "a.s": ["type", "position", "size", "color", "bounce", "mass", "friction", "air", "killer"]
    };

    // Find the first '{' and the second '{'
    let firstIndex = mapfile.indexOf('{');
    if (firstIndex === -1) return;

    let secondIndex = mapfile.indexOf('{', firstIndex + 1);
    if (secondIndex === -1) return;

    // Find the closing '}' after the second '{'
    let closingBraceIndex = mapfile.indexOf('}', secondIndex);
    if (closingBraceIndex === -1) return;

    // Extract the content between the second '{' and the closing '}'
    let contentBetweenBraces = mapfile.slice(secondIndex + 1, closingBraceIndex).trim();

    // Split the content by lines and process each line
    let startData = contentBetweenBraces
        .split('\n')
        .map(line => line.trim())   // Remove extra spaces around each line
        .filter(line => line.length > 0)  // Remove empty lines
        .map(line => processLine(line, schemas)); // Process each line based on schema
    
    console.log(startData);
}

function processLine(line, schemas) {
    // Split the line by the first `;`
    let [command, rest] = line.split(';').map(part => part.trim());

    // Extract the type (e.g., a.p, a.c, a.e, a.y, a.s)
    let type = command.split('(')[0];

    // Check if the type exists in the schemas array
    if (schemas[type]) {
        // Extract the arguments in between the parentheses
        let argsMatch = command.match(/\((.*)\)/);
        if (!argsMatch) return null; // Exit if no arguments found
        
        // Get the arguments, trimming any whitespace
        let argsString = argsMatch[1];
        
        // Use a regex to find all bracketed values (positions, rotations, sizes) correctly
        let args = argsString.split(/,(?=(?:[^\[]*\[|\[.*?[^\]]*\])*$)/).map(arg => arg.trim());

        let parsedArgs = parseArgsBySchema(args, schemas[type]);

        return parsedArgs;
    } else {
        return null;
    }
}

function parseArgsBySchema(args, schema) {
    let parsed = {};

    schema.forEach((key, index) => {
        if (key === "position" || key === "rotation" || key === "size") {
            // Check if the corresponding arg has square brackets
            let match = args[index] && args[index].match(/\[(.*)\]/);
            if (match) {
                parsed[key] = match[1].split(',').map(Number); // Convert to an array of numbers
            } else {
                parsed[key] = []; // Default to an empty array if not found
            }
        } else if (key === "color") {
            // Handle the color value and split it into shade and opacity
            let colorValue = args[index]; // Keep the original value with quotes
            if (colorValue.includes(',')) {
                let [shade, opacity] = colorValue.split(',').map(val => val.trim());
                parsed["color"] = { "shade": shade.replace(/["']/g, ''), "opacity": Number(opacity) }; // Remove quotes from shade
            } else {
                parsed["color"] = { "shade": colorValue.replace(/["']/g, ''), "opacity": 1 }; // Remove quotes from shade
            }
        } else {
            // For other values, assign directly (convert to number if applicable)
            parsed[key] = isNaN(args[index]) ? args[index] : Number(args[index]);
        }
    });

    return parsed;
}
</script>
</body>
</html>
