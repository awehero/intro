<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>URL to JS Map Converter</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        #result {
            margin-top: 20px;
            border: 1px solid #ccc;
            padding: 10px;
            background-color: #f9f9f9;
        }
    </style>
</head>
<body>
    <label for="query">Enter the full mapfile here:</label>
    <input type="text" id="query" placeholder="Script goes here..." style="width: 100%;">
    <button onclick="extractStartData()">Go!</button>
    <div>Made by awehero54</div>
    <div id="result"></div>

    <script>
   /*function extractStartData() {
    // Get the mapfile string from the input
    let mapfile = document.getElementById("query").value;

    // Step 1: Remove everything before the second '{'
    let firstIndex = mapfile.indexOf('{');
    let secondIndex = mapfile.indexOf('{', firstIndex + 1);
    if (secondIndex === -1) return; // Exit if there's no second '{'
    mapfile = mapfile.substring(secondIndex);

    // Step 2: Find the first '}' and extract the data between the first '{' and '}'
    let firstBraceIndex = mapfile.indexOf('{') + 1;
    let lastBraceIndex = mapfile.indexOf('}');
    if (firstBraceIndex === 0 || lastBraceIndex === -1) return; // Exit if braces are not found

    let initData = mapfile.substring(firstBraceIndex, lastBraceIndex);
*/
        let objects = []; // Array to store the final results

function formatString(input) {
    return input.replace(/[\[\])]/g, "") // Remove [, ], and )
                .replace(/\(/g, ",")    // Replace ( with ,
                .replace(/\s+/g, "")    // Remove all spaces
                .replace(/(\ba\.(p|c|e|y|s))/g, '"$1"'); // Add quotes around a.p, a.c, a.e, a.y, a.s
}

let input = `a.p([265.60035, -56.68965, -170.32965], [1.03, -0.22, -0.07], [70, 70, 70], "402c14", 0, 0, 0.6, false, false, false, false);
a.c([1, 2, 3], "ff0000");
a.e("event");
a.y(100);
a.s([4, 5, 6], true);
a.p([256.97042, -56.68958, -351.48958], [1.6, -0.22, -0.07], [70, 70, 70], "402c14", 0, 0, 0.6, false, false, false, false);`;

input = formatString(input);

// Split the formatted string into an array based on the ';' character
const outputArray = input.split(';').map(item => item.trim()).filter(item => item);

// Process each line
outputArray.forEach(row => {
    let fullRow = row; // The full row as a string
    let rowOne = fullRow.substring(0, 5); // The first 5 characters (e.g., "a.p")
    fullRow = fullRow.substring(fullRow.indexOf(",") + 1); // Everything after the first comma

    if (rowOne === "a.p" || rowOne === "a.y") {
        // Set listRow based on the expected format for a.p and a.y
        const values = fullRow.split(',');
        let listRow = [
            rowOne,                      // [0] a.p or a.y
            values[0],                  // [1] value before first comma
            values[1],                  // [2] value before second comma
            values[2],                  // [3] value before third comma
            values[3],                  // [4] value before fourth comma
            values[4],                  // [5] value before fifth comma
            values[5],                  // [6] value before sixth comma
            values[6],                  // [7] value before seventh comma
            values[7],                  // [8] value before eighth comma
            values[8],                  // [9] value before ninth comma
            values[9],                  // [10] value between the ninth comma and the second quotation mark
        ];

        let rowTwo = fullRow.split('"')[1]; // Everything after the first comma after the fourth quotation mark
        const rowTwoValues = rowTwo.split(',');
        listRow.push(...rowTwoValues); // Append values from rowTwo

        // Access rowTwo values based on the listRow array
        listRow.push(rowTwoValues[0]); // [11]
        listRow.push(rowTwoValues[1]); // [12]
        listRow.push(rowTwoValues[2]); // [13]
        listRow.push(rowTwoValues[3]); // [14]
        listRow.push(rowTwoValues[4]); // [15]

        // If rowOne is "a.p" (not "a.y"), handle the seventh comma value
        if (rowOne === "a.p") {
            listRow.push(rowTwoValues[5]); // [17]
        }

        objects.push(listRow); // Save the listRow array to objects

    } else if (rowOne === "a.c") {
        // Set listRow based on the expected format for a.c
        const values = fullRow.split(',');
        let listRow = [
            rowOne,                      // [0] a.c
            values[0],                  // [1] value before first comma
            values[1],                  // [2] value before second comma
            values[2],                  // [3] value before third comma
            values.slice(3).join(',')   // [4] everything after the third comma
        ];

        objects.push(listRow); // Save the listRow array to objects

    } else if (rowOne === "a.e") {
        // Set listRow based on the expected format for a.e
        const values = fullRow.split(',');
        let listRow = [
            rowOne,                      // [0] a.e
            values[0],                  // [1] value before first comma
            values[1],                  // [2] value before second comma
            values[2]                   // [3] value before third comma
        ];

        objects.push(listRow); // Save the listRow array to objects
    }
});

// Log the final objects array
console.log(objects);

    /*// Step 3: Split the initData string into an array of arguments
    let argArray = initData.match(/(?:a\.\w+\(.*?\);?)/g);
    
    // Create a mapping for the expected keys based on the type
    const typesMap = {
        "a.p": ["type", "xpos", "ypos", "zpos", "xrot", "yrot", "zrot", "xsiz", "ysiz", "zsiz", "color", "opacity", "friction", "air", "bounce", "jump", "drift", "mass", "killer"],
        "a.c": ["type", "xpos", "ypos", "zpos", "color", "opacity"],
        "a.e": ["type", "xpos", "ypos", "zpos"],
        "a.y": ["type", "xpos", "ypos", "zpos", "xrot", "yrot", "zrot", "xsiz", "ysiz", "zsiz", "color", "opacity", "bounce", "mass", "friction", "air", "topr", "killer"],
        "a.s": ["type", "xpos", "ypos", "zpos", "size", "color", "opacity", "bounce", "mass", "friction", "air", "killer"]
    };

    // Step 4: Initialize the startData array
    let startData = [];

    // Step 5: Loop through the args and parse the values
    for (let item of argArray) {
        let parsed = [];
        
        // Identify the type
        let typeKey = item.match(/^a\.(\w+)/);
        if (typeKey) {
            const type = typeKey[1];
            parsed.push(type); // Push the type as the first element
            
            // Remove the type identifier and parentheses
            let argsString = item.replace(/^a\.\w+\((.*)\);?$/, '$1');
            let args = argsString.split(',').map(arg => arg.trim().replace(/^\[|\]$/g, '')); // Remove brackets at the ends

            // Map parsed values based on the type
            for (let key of typesMap[`a.${type}`]) {
                if (key === "color") {
                    let colorValue = args.shift(); // Get the next value for color
                    if (colorValue) {
                        // Handle color value to split into color and opacity
                        if (colorValue.includes(',')) {
                            let [color, opacity] = colorValue.split(',').map(val => val.trim());
                            parsed.push(color.replace(/["']/g, '')); // Remove quotes from color
                            parsed.push(Number(opacity)); // Add opacity as a number
                        } else {
                            parsed.push(colorValue.replace(/["']/g, '')); // Remove quotes from color
                            parsed.push(1); // Default opacity
                        }
                    } else {
                        parsed.push(""); // Default color if color is missing
                        parsed.push(1); // Default opacity
                    }
                } else {
                    // For other attributes, get the next value and parse as number if possible
                    let value = args.shift();
                    parsed.push(value ? (isNaN(value) ? value : Number(value)) : null); // Convert to number or null if undefined
                }
            }

            // Push the parsed object to startData
            startData.push(parsed);
        }
    }

    // Display the result in the result div
    document.getElementById("result").innerText = JSON.stringify(startData, null, 2);
}*/
</script>
</body>
</html>
