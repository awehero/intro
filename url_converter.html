<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>URL to JS Map Converter</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        #result {
            margin-top: 20px;
            border: 1px solid #ccc;
            padding: 10px;
            background-color: #f9f9f9;
        }
    </style>
</head>
<body>
    <label for="query">Enter the full mapfile here:</label>
    <input type="text" id="query" placeholder="Script goes here..." style="width: 100%;">
    <button onclick="extractStartData()">Go!</button>
    <div>Made by awehero54</div>
    <div id="result"></div>

    <script>
   function extractStartData() {
    // Get the mapfile string from the input
    let mapfile = document.getElementById("query").value;

    // Step 1: Remove everything before the second '{'
    let firstIndex = mapfile.indexOf('{');
    let secondIndex = mapfile.indexOf('{', firstIndex + 1);
    if (secondIndex === -1) return; // Exit if there's no second '{'
    mapfile = mapfile.substring(secondIndex);

    // Step 2: Find the first '}' and extract the data between the first '{' and '}'
    let firstBraceIndex = mapfile.indexOf('{') + 1;
    let lastBraceIndex = mapfile.indexOf('}');
    if (firstBraceIndex === 0 || lastBraceIndex === -1) return; // Exit if braces are not found

    let initData = mapfile.substring(firstBraceIndex, lastBraceIndex);

    // Step 3: Split the initData string into an array of arguments
    let argArray = initData.match(/(?:a\.\w+\(.*?\);?)/g);
    
    // Create a mapping for the expected keys based on the type
    const typesMap = {
        "a.p": ["type", "xpos", "ypos", "zpos", "xrot", "yrot", "zrot", "xsiz", "ysiz", "zsiz", "color", "opacity", "friction", "air", "bounce", "jump", "drift", "mass", "killer"],
        "a.c": ["type", "xpos", "ypos", "zpos", "color", "opacity"],
        "a.e": ["type", "xpos", "ypos", "zpos"],
        "a.y": ["type", "xpos", "ypos", "zpos", "xrot", "yrot", "zrot", "xsiz", "ysiz", "zsiz", "color", "opacity", "bounce", "mass", "friction", "air", "topr", "killer"],
        "a.s": ["type", "xpos", "ypos", "zpos", "size", "color", "opacity", "bounce", "mass", "friction", "air", "killer"]
    };

    // Step 4: Initialize the startData array
    let startData = [];

    // Step 5: Loop through the args and parse the values
    for (let item of argArray) {
        let parsed = [];
        
        // Identify the type
        let typeKey = item.match(/^a\.(\w+)/);
        if (typeKey) {
            const type = typeKey[1];
            parsed.push(type); // Push the type as the first element
            
            // Remove the type identifier and parentheses
            let argsString = item.replace(/^a\.\w+\((.*)\);?$/, '$1');
            let args = argsString.split(',').map(arg => arg.trim().replace(/^\[|\]$/g, '')); // Remove brackets at the ends

            // Map parsed values based on the type
            for (let key of typesMap[`a.${type}`]) {
                if (key === "color") {
                    let colorValue = args.shift(); // Get the next value for color
                    if (colorValue) {
                        // Handle color value to split into color and opacity
                        if (colorValue.includes(',')) {
                            let [color, opacity] = colorValue.split(',').map(val => val.trim());
                            parsed.push(color.replace(/["']/g, '')); // Remove quotes from color
                            parsed.push(Number(opacity)); // Add opacity as a number
                        } else {
                            parsed.push(colorValue.replace(/["']/g, '')); // Remove quotes from color
                            parsed.push(1); // Default opacity
                        }
                    } else {
                        parsed.push(""); // Default color if color is missing
                        parsed.push(1); // Default opacity
                    }
                } else {
                    // For other attributes, get the next value and parse as number if possible
                    let value = args.shift();
                    parsed.push(value ? (isNaN(value) ? value : Number(value)) : null); // Convert to number or null if undefined
                }
            }

            // Push the parsed object to startData
            startData.push(parsed);
        }
    }

    // Display the result in the result div
    document.getElementById("result").innerText = JSON.stringify(startData, null, 2);
}
</script>
</body>
</html>
