<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Replay Viewer</title>
    <link rel="icon" href="https://awehero.github.io/intro/awehero.png" type="image/png">
	<script src="https://cdn.babylonjs.com/babylon.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        textarea { width: 100%; padding: 10px; font-family: monospace; }
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            line-height: 1.6;
            background-color: #f9f9f9;
            color: #333;
        }
        h1 {
            font-size: 2em;
            color: #007bff;
            margin-bottom: 10px;
        }
        div {
            margin-bottom: 10px;
            font-size: 1.2em;
        }
        p {
            margin-bottom: 10px;
            font-size: 1em;
        }
        textarea {
            width: 100%;
            max-width: 600px;
            padding: 10px;
            font-family: monospace;
            font-size: 1.7em;
            border: 1px solid #ccc;
            border-radius: 5px;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
        }
        button {
            padding: 10px 20px;
            font-size: 1em;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
        }
        button:hover {
            background-color: #0056b3;
        }
        #output {
            background-color: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #ddd;
            font-family: monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-x: auto;
            max-width: 100%;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
        }
        #copyButton {
            margin-top: 10px;
        }
        .button-group {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }
		#suggestions {
			position: absolute;
		    max-height: 12em;
			width: 15em;
		    overflow: auto;
		    background-color: white;
		    border: 1px solid black;
			display: none;
			padding-left: 5px;
    		padding-right: 5px;
		}
		.suggestion-item {
			font-size: 1em;
			cursor: pointer;
			border: 2px solid black;
		    border-radius: 5px;
		    padding-left: 5px;
		}
		.suggestion-item:hover {
			background-color: #f0f0f0;
		}
		#canvas {
			width: 100%;
			height: 50%;
			touch-action: none;
		}
		#slider {
			width: 75%;
		}
    </style>
    <body>
        <h1>Replay Viewer</h1>
		<p>Start typing a map name or map id and select it from the dropdown</p>
        <input type="search" id="input"></input><br>
		<div id="suggestions"></div><br>
		
		<p>Enter a UserUUID</p>
		<input id="userUuid"></input><br>
	
        <button onclick="findReplay()">Go!</button>
		<br>
        <canvas id="canvas"></canvas>
		<button id="playpause" onclick="togglePlayPause()"></button>
		<input id="slider" type="range" name="slider" min="0" max="100" value="0">
		<!-- <input id="speed" type -->
		<button id="togglePlayer" onclick="togglePlayer()">Toggle Player</button>
        <script>
			let input = document.getElementById("input");
			let useruuid = document.getElementById("userUuid");
			let suggestions = document.getElementById("suggestions");
			let slider = document.getElementById("slider");
			let toggleplayer = document.getElementById("togglePlayer");
			let nodes = [];
			let state = "pause";
			let score = 0;
			fetch('https://awehero.github.io/intro/minitools/mapdata.js')
				.then(response => response.text())
				.then(code => {
					eval(code);
					mapData = mapData.replace(/\;/g, "$").split("$");
					for (var i = 0; i < mapData.length; i++) {
					    mapData[i] = mapData[i].split("|");
					}
					input.addEventListener('input', function() {
						let text = input.value.toLowerCase();
						let maps = mapData.filter(function(map) {
						    return (map[1].indexOf(text.toLowerCase()) != -1) || (map[0].toLowerCase().indexOf(text.toLowerCase()) != -1)
						});
						if (maps.length > 0 && text.length != 0) {
							suggestions.innerHTML = '';
							maps.forEach(map=>{
								let suggestionItem = document.createElement("div");
								suggestionItem.classList.add("suggestion-item");
								suggestionItem.textContent = map[0];
								suggestionItem.id = map[1];
								suggestionItem.addEventListener("click", function() {
									input.value = this.id;
									getMap();
									suggestions.style.display = "none";
								});
								suggestions.appendChild(suggestionItem);
							});
							suggestions.style.display = "block";
						} else {
							suggestions.style.display = "none";
						}
					});
				})
				.catch(err => console.error('Error loading script:', err));
			
			function getMap() {
			    let map = input.value.trim();
			    fetch('https://icedodo.onionfist.com/maps/' + map + '.js')
			        .then(response => {
			            if (!response.ok) throw new Error('HTTP ' + response.status);
			            return response.text();
			        })
			        .then(code => {
			            mapfile = code;
						loadMap();
			        })
			        .catch(error => console.error('Error: ' + error));
			}

			function findReplay() {
            	let map = input.value.trim();
				let userId = useruuid.value.trim();
            	fetch('https://icedodo-api.onionfist.com/api/get_replay_nodes', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
						'Accept': '*/*',
						'Accept-Encoding': 'gzip, deflate, br, zstd',
						'Accept-Language': 'en-US,en;q=0.9'
					},
						body: JSON.stringify({
						userUuid: userId,
						mapId: map
					})
				})
				.then(response => response.json())
				.then(data => {
					nodes[nodes.length] = data.replayNodes;
					let sliderTemp = 0;
					for (var i = 0; i < nodes.length; i++) {
						if (nodes[i].length > sliderTemp) {
							sliderTemp = nodes[i].length - 1;
						}
					}
					slider.max = sliderTemp;
				})
				.catch(error => console.error('Error:' + error));
        	}
			
			slider.addEventListener('input', () => {
		    	score = parseFloat(slider.value);
				moveNodes();
		    });
			
			function togglePlayPause() {
				if (state == "pause") {
					state = "play";
				} else {
					state = "pause";
				}
			}

			setInterval(function() {
				if (state == "play") {
					if (score <= slider.max) {
						moveNodes();
						score++;
					}
				}
			}, 10);

			function moveNodes() {
				for (var i = 0; i < players.length; i++) {
					slider.value = score;
					players[i].position.x = nodes[i][score].px;
					players[i].position.y = nodes[i][score].py;
					players[i].position.z = nodes[i][score].pz;
					players[i].rotation.x = nodes[i][score].rx;
					players[i].rotation.y = nodes[i][score].ry;
					players[i].rotation.z = nodes[i][score].rz;
					players[i].scaling.x = nodes[i][score].sx;
					players[i].scaling.y = nodes[i][score].sy;
					players[i].scaling.z = nodes[i][score].sz;
					if (activeCamera == followCamera) {
						rotation = nodes[players.indexOf(activePlayer)][score].r;
					}
				}
			}





			// Scene
			let objects = "";
			let planes = [];
			let platforms = [];
			let cones = [];
			let endings = [];
			let cylinders = [];
			let spheres = [];
			let monkeys = [];
			let mapfile = "";
			let players = [];
			var canvas = document.getElementById("canvas");
            var engine = new BABYLON.Engine(canvas, true);
			var scene = new BABYLON.Scene(engine);
			var followCamera = new BABYLON.UniversalCamera("followCamera", new BABYLON.Vector3(0, 5, -10), scene);
			followCamera.fov = 1.2;
			let activeCamera = followCamera;
			var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
			light.specular = new BABYLON.Color3(0.95, 0.95, 0.81);
			light.parent = activeCamera;
			window.rotation = 0;
			window.radius = 2.5;
		    window.cameraRightAngle = 0;
		    window.cam_horizontal = radius * radius;
		    window.cam_vertical = cam_horizontal * Math.tan(radius * 1.3);
		    window.cam_depression = 0.3;
			var player1 = BABYLON.MeshBuilder.CreateBox('player1', { width: 0.5, height: 0.08, depth: 0.5 }, scene);
			players.push(player1);
			var player2 = BABYLON.MeshBuilder.CreateBox('player2', { width: 0.5, height: 0.08, depth: 0.5 }, scene);
			players.push(player2);
			var activePlayer = player1;
			function updateFollowCamera() {
		    	const rotation_offsetted = window.rotation + window.cameraRightAngle;
		        followCamera.position.x = activePlayer.position.x + Math.sin(rotation_offsetted) * window.cam_horizontal;
		        followCamera.position.z = activePlayer.position.z + Math.cos(rotation_offsetted) * window.cam_horizontal;
		        followCamera.position.y = activePlayer.position.y + window.cam_vertical +2; //Fix later
		        followCamera.rotation.y = Math.PI + rotation_offsetted;
		        followCamera.rotation.x = window.cam_depression;
		    }
			function togglePlayer() {
				let next = players.indexOf(activePlayer) + 1;
				if (next > players.length - 1) next = 0;
				activePlayer = players[next];
			}
			var freeCamera = new BABYLON.UniversalCamera("freeCamera", new BABYLON.Vector3(0, 5, -10), scene);
			freeCamera.rotation = new BABYLON.Vector3(0, Math.PI, 0);
			freeCamera.position = followCamera.position;
		
			let keys = {};
			window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
			window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);
		
			function updateFreeCamera() {
				const speed = 0.5;
				const rotSpeed = 0.01;
				if (keys["w"]) { freeCamera.position.x += Math.sin(freeCamera.rotation.y) * speed; freeCamera.position.z += Math.cos(freeCamera.rotation.y) * speed; }
				if (keys["s"]) { freeCamera.position.x -= Math.sin(freeCamera.rotation.y) * speed; freeCamera.position.z -= Math.cos(freeCamera.rotation.y) * speed; }
				if (keys["a"]) { freeCamera.position.x += Math.sin(freeCamera.rotation.y - Math.PI / 2) * speed; freeCamera.position.z += Math.cos(freeCamera.rotation.y - Math.PI / 2) * speed; }
				if (keys["d"]) { freeCamera.position.x += Math.sin(freeCamera.rotation.y + Math.PI / 2) * speed; freeCamera.position.z += Math.cos(freeCamera.rotation.y + Math.PI / 2) * speed; }
				if (keys["e"]) freeCamera.position.y += speed;
				if (keys["c"]) freeCamera.position.y -= speed;
				if (keys["arrowup"]) freeCamera.rotation.x -= rotSpeed;
				if (keys["arrowdown"]) freeCamera.rotation.x += rotSpeed;
			}
		
			scene.activeCamera = activeCamera;
			scene.activeCamera.attachControl(canvas, true);
		
			window.addEventListener("keydown", e => {
				if (e.key === "Tab") {
					e.preventDefault();
					activeCamera.detachControl();
					if (activeCamera === followCamera) {
						activeCamera = freeCamera;
					} else {
						activeCamera = followCamera;
					}
					scene.activeCamera = activeCamera;
					activeCamera.attachControl(canvas, true);
				}
			});
			engine.runRenderLoop(() => {
		        if (activeCamera === followCamera) updateFollowCamera();
		        if (activeCamera === freeCamera) updateFreeCamera();
		        scene.render();
		    });
			window.addEventListener("resize", () => engine.resize());
			
			function loadMap() {
				let removers = ['P','C','E','Y','S'];
				for (var i = scene.meshes.length-1; i > -1; i--) {
					if (removers.includes(scene.meshes[i].id.substring(0,1))) {
						scene.meshes[i].dispose();
					}
				}
				nodes = [];
				mapfile = mapfile.replace(/\s+/g,"");
				objects = mapfile.substring(mapfile.indexOf("init"),mapfile.indexOf("post"));
				objects = objects.substring(objects.indexOf("{")+1,objects.indexOf("}"));
				objects = objects.split(";");
				for (var i = 0; i < objects.length; i++) {
					let type = objects[i].substring(0,3);
					objects[i] = objects[i].substring(4,objects[i].length-1);
					objects[i] = objects[i].replace(/\[/g,"").replace(/\]/g,"");
					if (objects[i].indexOf("\"") != -1) {
						objects[i] = objects[i].substring(0,objects[i].indexOf("\"")) + objects[i].substring(objects[i].indexOf("\""),objects[i].lastIndexOf("\"")).replace(/\,/g,"?") + objects[i].substring(objects[i].lastIndexOf("\""),objects[i].length);
					}
					objects[i] = objects[i].replace(/\"/g,"");
					objects[i] = objects[i].split(",");
					for (var j = 0; j < objects[i].length-1; j++) {
						if (objects[i][j] == parseFloat(objects[i][j])) {
							objects[i][j] = parseFloat(objects[i][j]);
						}
					}
					let obj = createMesh(type, objects, i);
					if (obj) scene.addMesh(obj);
				}
			}
			
			function createMesh(type, objects, i) {
				 switch (type) {
					 case 'a.p':
						 return createObject("P",objects[i][0],objects[i][1],objects[i][2],objects[i][3],objects[i][4],objects[i][5],objects[i][6],objects[i][7],objects[i][8],objects[i][9]);
					 case 'a.c':
						 return createObject("C",objects[i][0],objects[i][1],objects[i][2],objects[i][3]);
					 case 'a.e':
						 return createObject("E",objects[i][0],objects[i][1],objects[i][2]);
					 case 'a.y':
						 return createObject("Y",objects[i][0],objects[i][1],objects[i][2],objects[i][3],objects[i][4],objects[i][5],objects[i][6],objects[i][7],objects[i][8],objects[i][9]);
					 case 'a.s':
						 return createObject("S",objects[i][0],objects[i][1],objects[i][2],objects[i][3],objects[i][4]);
				 }
			 }
			
			function createObject(shape,zero,one,two,three,four,five,six,seven,eight,nine) {
				let obj;
				let mat = new BABYLON.StandardMaterial("mat", scene);
				switch (shape) {
					case "P":
				        obj = BABYLON.MeshBuilder.CreateBox("P"+platforms.length, { size: 1 }, scene);
						if (nine.length == 6) {
							mat.diffuseColor = new BABYLON.Color3.FromHexString("#"+nine);
						} else if (nine.length > 6) {
							mat.diffuseColor = new BABYLON.Color3.FromHexString("#"+nine.substring(0,6));
							mat.alpha = parseFloat(nine.substring(7));
						} else {
							switch (parseFloat(nine)) {
								case -1: mat.alpha = 0; break;
							}
						}
						obj.material = mat;
						obj.position = new BABYLON.Vector3(zero, one, two);
						obj.rotation = new BABYLON.Vector3(four, three, five);
						obj.scaling = new BABYLON.Vector3(six, seven, eight);
						platforms.push(obj);
						break;
				    case "C":
				        obj = BABYLON.MeshBuilder.CreateCylinder("C"+cones.length, { height: 0.5, diameterTop: 0, diameterBottom: 0.5, tessellation: 5 }, scene);
						obj.position = new BABYLON.Vector3(zero, one, two);
						obj.scaling.y = 1.2;
						cones.push(obj);
						if (three.length == 6) {
							mat.diffuseColor = new BABYLON.Color3.FromHexString("#"+three);
						} else if (three.length > 6) {
							mat.diffuseColor = new BABYLON.Color3.FromHexString("#"+three.substring(0,6));
							mat.alpha = parseFloat(three.substring(7));
						} else {
							switch (parseFloat(three)) {
								case -1: mat.alpha = 0; break;
							}
						}
						obj.material = mat;
						break;
				    case "E":
				        obj = BABYLON.MeshBuilder.CreateCylinder("E"+endings.length, { height: 2.0, diameter: 2.0, tessellation: 8 }, scene);
						obj.position = new BABYLON.Vector3(zero, one, two);
						endings.push(obj);
						break;
				    case "Y":
				        obj = BABYLON.MeshBuilder.CreateCylinder("Y"+cylinders.length, { height: 1.0, diameter: 1.0, tessellation: 12 }, scene);
						if (nine.length == 6) {
							mat.diffuseColor = new BABYLON.Color3.FromHexString("#"+nine);
						} else if (nine.length > 6) {
							mat.diffuseColor = new BABYLON.Color3.FromHexString("#"+nine.substring(0,6));
							mat.alpha = parseFloat(nine.substring(7));
						} else {
							switch (parseFloat(nine)) {
								case -1: mat.alpha = 0; break;
							}
						}
						obj.material = mat;
						obj.position = new BABYLON.Vector3(zero, one, two);
						obj.rotation = new BABYLON.Vector3(four, three, five);
						obj.scaling = new BABYLON.Vector3(six, seven, eight);
						cylinders.push(obj);
						break;
					case "S":
						obj = BABYLON.MeshBuilder.CreateSphere("S"+spheres.length, { segments: 10, diameter: 1.0 }, scene);
						if (four.length == 6) {
							mat.diffuseColor = new BABYLON.Color3.FromHexString("#"+four);
						} else if (four.length > 6) {
							mat.diffuseColor = new BABYLON.Color3.FromHexString("#"+four.substring(0,6));
							mat.alpha = parseFloat(four.substring(7));
						} else {
							switch (parseFloat(four)) {
								case -1: mat.alpha = 0; break;
							}
						}
						obj.material = mat;
						obj.position = new BABYLON.Vector3(zero, one, two);
						obj.scaling = new BABYLON.Vector3(three, three, three);
						spheres.push(obj);
						break;
				}
				return obj;
			}
        </script>
    </body>
</html>
