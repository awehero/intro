<!DOCTYPE html>
<html lang="en">
	<head>
	    <meta charset="UTF-8">
	    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	    <title>Replay Viewer</title>
	    <link rel="icon" href="https://awehero.github.io/intro/awehero.png" type="image/png">
		<script src="https://cdn.babylonjs.com/babylon.js"></script>
	    <style>
	        body { font-family: Arial, sans-serif; margin: 20px; }
	        textarea { width: 100%; padding: 10px; font-family: monospace; }
	        body {
	            font-family: Arial, sans-serif;
	            margin: 20px;
	            line-height: 1.6;
	            background-color: #f9f9f9;
	            color: #333;
	        }
	        h1 {
	            font-size: 2em;
	            color: #007bff;
	            margin-bottom: 10px;
	        }
	        div {
	            font-size: 1.2em;
	        }
	        p {
	            margin-bottom: 10px;
	            font-size: 1em;
	        }
	        textarea {
	            width: 100%;
	            max-width: 600px;
	            padding: 10px;
	            font-family: monospace;
	            font-size: 1.7em;
	            border: 1px solid #ccc;
	            border-radius: 5px;
	            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
	        }
	        button {
	            padding: 10px 20px;
	            font-size: 1em;
	            background-color: #007bff;
	            color: white;
	            border: none;
	            border-radius: 5px;
	            cursor: pointer;
	            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
	        }
	        button:hover {
	            background-color: #0056b3;
	        }
	        #output {
	            background-color: #f4f4f4;
	            padding: 15px;
	            border-radius: 5px;
	            border: 1px solid #ddd;
	            font-family: monospace;
	            white-space: pre-wrap;
	            word-wrap: break-word;
	            overflow-x: auto;
	            max-width: 100%;
	            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.1);
	        }
	        #copyButton {
	            margin-top: 10px;
	        }
	        .button-group {
	            display: flex;
	            gap: 10px;
	            margin: 10px 0;
	        }
			#suggestions {
				position: absolute;
			    max-height: 12em;
				width: 15em;
			    overflow: auto;
			    background-color: white;
			    border: 1px solid black;
				display: none;
				padding-left: 5px;
	    		padding-right: 5px;
			}
			#replays {
				position: absolute;
			    max-height: 12em;
				width: 15em;
			    overflow: auto;
			    background-color: white;
			    border: 1px solid black;
				display: none;
				padding-left: 5px;
	    		padding-right: 5px;
			}
			.suggestion-item {
				font-size: 1em;
				cursor: pointer;
				border: 2px solid black;
			    border-radius: 5px;
			    padding-left: 5px;
				margin-bottom: 10px;
			}
			.suggestion-item:hover {
				background-color: #f0f0f0;
			}
			#canvas {
				width: 100%;
				height: 50%;
				touch-action: none;
			}
			#slider {
				width: 75%;
			}
			#inputDisplay {
				position: absolute;
				bottom: 2%;
				left: 2%;
				width: 120px;
				height: 120px;
				border: 2px solid black;
				border-radius: 10px;
				display: flex;
				flex-direction: column;
				justify-content: space-between;
				align-items: center;
				backdrop-filter: blur(1px);
			}
			#inputDisplayTop, #inputDisplayBottom {
				width: 100%;
				display: flex;
				justify-content: center;
				align-items: center;
			}
			#inputDisplayBottom {
				justify-content: space-around;
			}
			.inputDisplayButton {
				width: 40px;
				height: 40px;
				display: flex;
				justify-content: center;
				align-items: center;
				color: lightgray;
			}
			.inputDisplayButton svg {
				width: 100%;
				height: 100%;
			}
	    </style>
	</head>
    <body>
        <h1>Replay Viewer</h1>
		<p>Start typing a map name or map id and select it from the dropdown</p>
        <input type="search" id="input"><br>
		<div id="suggestions"></div><br>
		
		<p>Enter a UserUUID</p>
		<input id="userUuid"><br>
		<div id="replays"></div><br>
	
        <!-- <button onclick="findReplay()">Go!</button> -->
		<br>
        <canvas id="canvas"></canvas>
		<button id="playpause" onclick="togglePlayPause()"></button>
		<input id="slider" type="range" name="slider" min="0" max="100" value="0">
		<input id="speed" type="range" name="speed" min="0.1" max="5" value="1" step="0.1">
		<p id=speedDisplay>x1</p>
		<button id="togglePlayer" onclick="togglePlayer()">Toggle Player</button>
		<div id="inputDisplay">
			<div id="inputDisplayTop">
				<div id="up" class="inputDisplayButton"></div>
			</div>
			<div id="inputDisplayBottom">
				<div id="left" class="inputDisplayButton"></div>
				<div id="down" class="inputDisplayButton"></div>
				<div id="right" class="inputDisplayButton"></div>
			</div>
		</div>
        <script>
			let input = document.getElementById("input");
			let userUuid = document.getElementById("userUuid");
			let suggestions = document.getElementById("suggestions");
			let replays = document.getElementById("replays");
			let slider = document.getElementById("slider");
			let speed = document.getElementById("speed");
			let speedDisplay = document.getElementById("speedDisplay");
			let toggleplayer = document.getElementById("togglePlayer");
			let up = document.getElementById("up");
			let down = document.getElementById("down");
			let left = document.getElementById("left");
			let right = document.getElementById("right");
			let replayData = "";
			let nodes = [];
			let state = "pause";
			let score = 0;
			let interval;
			let svgs = {};
			let svgUrls = {
				up: "https://awehero.github.io/intro/svgs/arrow-up-square.svg",
				down: "https://awehero.github.io/intro/svgs/arrow-down-square.svg",
				left: "https://awehero.github.io/intro/svgs/arrow-left-square.svg",
				right: "https://awehero.github.io/intro/svgs/arrow-right-square.svg",
				up_pressed: "https://awehero.github.io/intro/svgs/arrow-up-square-fill.svg",
				down_pressed: "https://awehero.github.io/intro/svgs/arrow-down-square-fill.svg",
				left_pressed: "https://awehero.github.io/intro/svgs/arrow-left-square-fill.svg",
				right_pressed: "https://awehero.github.io/intro/svgs/arrow-right-square-fill.svg",
			};
			Promise.all(Object.entries(svgUrls).map(async ([key, url]) => {
				const res = await fetch(url);
				svgs[key] = await res.text();
			}))
			.then(() => {
			  	console.log("All SVGs loaded!");
				up.innerHTML = svgs.up;
				down.innerHTML = svgs.down;
				left.innerHTML = svgs.left;
				right.innerHTML = svgs.right;
			});
			fetch('https://awehero.github.io/intro/minitools/mapdata.js')
				.then(response => response.text())
				.then(code => {
					eval(code);
					mapData = mapData.replace(/\;/g, "$").split("$");
					for (var i = 0; i < mapData.length; i++) {
					    mapData[i] = mapData[i].split("|");
					}
					input.addEventListener('input', function() {
						let text = input.value.toLowerCase();
						let maps = mapData.filter(function(map) {
						    return (map[1].indexOf(text.toLowerCase()) != -1) || (map[0].toLowerCase().indexOf(text.toLowerCase()) != -1)
						});
						if (maps.length > 0 && text.length != 0) {
							suggestions.innerHTML = '';
							maps.forEach(map=>{
								let suggestionItem = document.createElement("div");
								suggestionItem.classList.add("suggestion-item");
								suggestionItem.textContent = map[0];
								suggestionItem.id = map[1];
								suggestionItem.addEventListener("click", function() {
									input.value = this.id;
									getMap();
									getAllReplays();
									suggestions.style.display = "none";
								});
								suggestions.appendChild(suggestionItem);
							});
							suggestions.style.display = "block";
						} else {
							suggestions.style.display = "none";
						}
					});
				})
				.catch(err => console.error('Error loading script:', err));

			function getAllReplays() {
				fetch('https://icedodo-api.onionfist.com/api/get_replay_listings', {
						method: 'POST',
						headers: {
							'Content-Type': 'application/json',
							'Accept': '*/*',
							'Accept-Encoding': 'gzip, deflate, br, zstd',
							'Accept-Language': 'en-US,en;q=0.9'
						},
							body: JSON.stringify({
								includeUid: "44f8f01d-048c-415e-9a56-bcfbeaefa076",
								mapId: input.value,
								ordering: 2
						})
					})
					.then(response => response.json())
					.then(data => {
						replayData = data.replayListings;
						userUuid.addEventListener('input', function() {
							let text = userUuid.value.toLowerCase();
							let filterReplays = replayData.filter(function(replay) {
							    return (replay.username.indexOf(text.toLowerCase()) != -1)
							});
							if (filterReplays.length > 0) {
								replays.innerHTML = '';
								filterReplays.forEach(replay=>{
									let suggestionItem = document.createElement("div");
									suggestionItem.classList.add("suggestion-item");
									suggestionItem.textContent = replay.username;
									suggestionItem.id = replay.userUuid;
									suggestionItem.addEventListener("click", function() {
										userUuid.value = this.id;
										findReplay();
										replays.style.display = "none";
									});
									replays.appendChild(suggestionItem);
								});
								replays.style.display = "block";
							} else {
								replays.style.display = "none";
							}
						});
					})
					.catch(error => console.error('Error:' + error));
			}
			
			function getMap() {
			    let map = input.value.trim();
			    fetch('https://icedodo.onionfist.com/maps/' + map + '.js')
			        .then(response => {
			            if (!response.ok) throw new Error('HTTP ' + response.status);
			            return response.text();
			        })
			        .then(code => {
			            mapfile = code;
						loadMap();
			        })
			        .catch(error => console.error('Error: ' + error));
			}

			function findReplay() {
            	let map = input.value.trim();
				let userId = userUuid.value.trim();
            	fetch('https://icedodo-api.onionfist.com/api/get_replay_nodes', {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
						'Accept': '*/*',
						'Accept-Encoding': 'gzip, deflate, br, zstd',
						'Accept-Language': 'en-US,en;q=0.9'
					},
						body: JSON.stringify({
						userUuid: userId,
						mapId: map
					})
				})
				.then(response => response.json())
				.then(data => {
					nodes[nodes.length] = data.replayNodes;
					let sliderTemp = 0;
					for (var i = 0; i < nodes.length; i++) {
						if (nodes[i].length > sliderTemp) {
							sliderTemp = nodes[i].length - 1;
						}
					}
					slider.max = sliderTemp;
					for (var i = 0; i < nodes.length; i++) {
						while (nodes[i].length < sliderTemp - 1) {
							nodes[i][nodes[i].length] = nodes[i][nodes[i].length - 1]
						}
					}
				})
				.catch(error => console.error('Error:' + error));
        	}
			
			slider.addEventListener('input', () => {
		    	score = parseFloat(slider.value);
				moveNodes();
		    });
			speed.addEventListener("input", () => {
				startLoop();
				speedDisplay.innerText = "x" + speed.value();
			});
			
			function togglePlayPause() {
				if (state == "pause") {
					state = "play";
				} else {
					state = "pause";
				}
			}

			function startLoop() {
			    clearInterval(interval);
			    interval = setInterval(function() {
			        if (state === "play") {
			            if (score <= slider.max) {
			                moveNodes();
			                score++;
			            }
			        }
			    }, (1000 / 60) / Number(speed.value));
			}
			startLoop();

			function moveNodes() {
				for (var i = 0; i < nodes.length; i++) {
					slider.value = score;
					players[i].position.x = nodes[i][score].px;
					players[i].position.y = nodes[i][score].py;
					players[i].position.z = nodes[i][score].pz;
					let angles = new BABYLON.Quaternion(nodes[i][score].rx,nodes[i][score].ry,nodes[i][score].rz,nodes[i][score].rw).toEulerAngles();
					players[i].rotation.x = angles.x;
					players[i].rotation.y = angles.y;
					players[i].rotation.z = angles.z;
					players[i].scaling.x = nodes[i][score].sx;
					players[i].scaling.y = nodes[i][score].sy;
					players[i].scaling.z = nodes[i][score].sz;
					if (activeCamera == followCamera) {
						let playerIndex = players.indexOf(activePlayer);
						rotation = nodes[playerIndex][score].r;
						updateInputDisplay(playerIndex);
						// fps.value = nodes[players.indexOf(activePlayer)][score].fps;
					}
				}
			}
			function updateInputDisplay(p) {
				if (nodes[p][score].w) {
					up.innerHTML = svgs.up_pressed;
				} else {
					up.innerHTML = svgs.up;
				}
				if (nodes[p][score].s) {
					down.innerHTML = svgs.down_pressed;
				} else {
					down.innerHTML = svgs.down;
				}
				if (nodes[p][score].a) {
					left.innerHTML = svgs.left_pressed;
				} else {
					left.innerHTML = svgs.left;
				}
				if (nodes[p][score].d) {
					right.innerHTML = svgs.right_pressed;
				} else {
					right.innerHTML = svgs.right;
				}
			}





			// Scene
			let objects = "";
			let planes = [];
			let platforms = [];
			let cones = [];
			let endings = [];
			let cylinders = [];
			let spheres = [];
			let monkeys = [];
			let mapfile = "";
			let players = [];
			var canvas = document.getElementById("canvas");
            var engine = new BABYLON.Engine(canvas, true);
			var scene = new BABYLON.Scene(engine);
			var followCamera = new BABYLON.UniversalCamera("followCamera", new BABYLON.Vector3(0, 5, -10), scene);
			followCamera.fov = 1.2;
			let activeCamera = followCamera;
			var light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
			light.specular = new BABYLON.Color3(0.95, 0.95, 0.81);
			light.parent = activeCamera;
			window.rotation = 0;
			window.radius = 2.5;
		    window.cameraRightAngle = 0;
		    window.cam_horizontal = radius * radius;
		    window.cam_vertical = cam_horizontal * Math.tan(radius * 1.3);
		    window.cam_depression = 0.3;
			var player1 = BABYLON.MeshBuilder.CreateBox('player1', { width: 0.5, height: 0.08, depth: 0.5 }, scene);
			players.push(player1);
			var player2 = BABYLON.MeshBuilder.CreateBox('player2', { width: 0.5, height: 0.08, depth: 0.5 }, scene);
			players.push(player2);
			var player3 = BABYLON.MeshBuilder.CreateBox('player3', { width: 0.5, height: 0.08, depth: 0.5 }, scene);
			players.push(player3);
			var player4 = BABYLON.MeshBuilder.CreateBox('player4', { width: 0.5, height: 0.08, depth: 0.5 }, scene);
			players.push(player4);
			var player5 = BABYLON.MeshBuilder.CreateBox('player5', { width: 0.5, height: 0.08, depth: 0.5 }, scene);
			players.push(player5);
			var player6 = BABYLON.MeshBuilder.CreateBox('player6', { width: 0.5, height: 0.08, depth: 0.5 }, scene);
			players.push(player6);
			var player7 = BABYLON.MeshBuilder.CreateBox('player7', { width: 0.5, height: 0.08, depth: 0.5 }, scene);
			players.push(player7);
			var player8 = BABYLON.MeshBuilder.CreateBox('player8', { width: 0.5, height: 0.08, depth: 0.5 }, scene);
			players.push(player8);
			var player9 = BABYLON.MeshBuilder.CreateBox('player9', { width: 0.5, height: 0.08, depth: 0.5 }, scene);
			players.push(player9);
			var player10 = BABYLON.MeshBuilder.CreateBox('player10', { width: 0.5, height: 0.08, depth: 0.5 }, scene);
			players.push(player10);
			var activePlayer = player1;
			function updateFollowCamera() {
		    	const rotation_offsetted = window.rotation + window.cameraRightAngle;
		        followCamera.position.x = activePlayer.position.x + Math.sin(rotation_offsetted) * window.cam_horizontal;
		        followCamera.position.z = activePlayer.position.z + Math.cos(rotation_offsetted) * window.cam_horizontal;
		        followCamera.position.y = activePlayer.position.y + window.cam_vertical +2; //Fix later
		        followCamera.rotation.y = Math.PI + rotation_offsetted;
		        followCamera.rotation.x = window.cam_depression;
				followCamera.setTarget(activePlayer.position);
		    }
			function togglePlayer() {
				let next = players.indexOf(activePlayer) + 1;
				if (next > players.length - 1) next = 0;
				activePlayer = players[next];
			}
			var freeCamera = new BABYLON.UniversalCamera("freeCamera", new BABYLON.Vector3(0, 5, -10), scene);
			freeCamera.rotation = new BABYLON.Vector3(0, Math.PI, 0);
			freeCamera.position = followCamera.position;
		
			let keys = {};
			window.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
			window.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);
		
			function updateFreeCamera() {
				const speed = 0.5;
				const rotSpeed = 0.01;
				if (keys["w"]) { freeCamera.position.x += Math.sin(freeCamera.rotation.y) * speed; freeCamera.position.z += Math.cos(freeCamera.rotation.y) * speed; }
				if (keys["s"]) { freeCamera.position.x -= Math.sin(freeCamera.rotation.y) * speed; freeCamera.position.z -= Math.cos(freeCamera.rotation.y) * speed; }
				if (keys["a"]) { freeCamera.position.x += Math.sin(freeCamera.rotation.y - Math.PI / 2) * speed; freeCamera.position.z += Math.cos(freeCamera.rotation.y - Math.PI / 2) * speed; }
				if (keys["d"]) { freeCamera.position.x += Math.sin(freeCamera.rotation.y + Math.PI / 2) * speed; freeCamera.position.z += Math.cos(freeCamera.rotation.y + Math.PI / 2) * speed; }
				if (keys["e"]) freeCamera.position.y += speed;
				if (keys["c"]) freeCamera.position.y -= speed;
				if (keys["arrowup"]) freeCamera.rotation.x -= rotSpeed;
				if (keys["arrowdown"]) freeCamera.rotation.x += rotSpeed;
			}
		
			scene.activeCamera = activeCamera;
			scene.activeCamera.attachControl(canvas, true);
		
			window.addEventListener("keydown", e => {
				if (e.key === "Tab") {
					e.preventDefault();
					activeCamera.detachControl();
					if (activeCamera === followCamera) {
						activeCamera = freeCamera;
					} else {
						activeCamera = followCamera;
					}
					scene.activeCamera = activeCamera;
					activeCamera.attachControl(canvas, true);
				}
			});
			engine.runRenderLoop(() => {
		        if (activeCamera === followCamera) updateFollowCamera();
		        if (activeCamera === freeCamera) updateFreeCamera();
		        scene.render();
		    });
			window.addEventListener("resize", () => engine.resize());
			
			function loadMap() {
				let removers = ['P','C','E','Y','S'];
				for (var i = scene.meshes.length-1; i > -1; i--) {
					if (removers.includes(scene.meshes[i].id.substring(0,1))) {
						scene.meshes[i].dispose();
					}
				}
				nodes = [];
				mapfile = mapfile.replace(/\s+/g,"");
				objects = mapfile.substring(mapfile.indexOf("init"),mapfile.indexOf("post"));
				objects = objects.substring(objects.indexOf("{")+1,objects.indexOf("}"));
				objects = objects.split(";");
				for (var i = 0; i < objects.length; i++) {
					let type = objects[i].substring(0,3);
					objects[i] = objects[i].substring(4,objects[i].length-1);
					objects[i] = objects[i].replace(/\[/g,"").replace(/\]/g,"");
					if (objects[i].indexOf("\"") != -1) {
						objects[i] = objects[i].substring(0,objects[i].indexOf("\"")) + objects[i].substring(objects[i].indexOf("\""),objects[i].lastIndexOf("\"")).replace(/\,/g,"?") + objects[i].substring(objects[i].lastIndexOf("\""),objects[i].length);
					}
					objects[i] = objects[i].replace(/\"/g,"");
					objects[i] = objects[i].split(",");
					for (var j = 0; j < objects[i].length-1; j++) {
						if (objects[i][j] == parseFloat(objects[i][j])) {
							objects[i][j] = parseFloat(objects[i][j]);
						}
					}
					let obj = createMesh(type, objects, i);
					if (obj) scene.addMesh(obj);
				}
			}
			
			function createMesh(type, objects, i) {
				 switch (type) {
					 case 'a.p':
						 return createObject("P",objects[i][0],objects[i][1],objects[i][2],objects[i][3],objects[i][4],objects[i][5],objects[i][6],objects[i][7],objects[i][8],objects[i][9]);
					 case 'a.c':
						 return createObject("C",objects[i][0],objects[i][1],objects[i][2],objects[i][3]);
					 case 'a.e':
						 return createObject("E",objects[i][0],objects[i][1],objects[i][2]);
					 case 'a.y':
						 return createObject("Y",objects[i][0],objects[i][1],objects[i][2],objects[i][3],objects[i][4],objects[i][5],objects[i][6],objects[i][7],objects[i][8],objects[i][9]);
					 case 'a.s':
						 return createObject("S",objects[i][0],objects[i][1],objects[i][2],objects[i][3],objects[i][4]);
				 }
			 }
			
			function createObject(shape,zero,one,two,three,four,five,six,seven,eight,nine) {
				let obj;
				let mat = new BABYLON.StandardMaterial("mat", scene);
				switch (shape) {
					case "P":
				        obj = BABYLON.MeshBuilder.CreateBox("P"+platforms.length, { size: 1 }, scene);
						if (typeof nine == 'undefined') {
							
						} else if (nine.length == 6) {
							mat.diffuseColor = new BABYLON.Color3.FromHexString("#"+nine);
						} else if (nine.length > 6) {
							mat.diffuseColor = new BABYLON.Color3.FromHexString("#"+nine.substring(0,6));
							mat.alpha = parseFloat(nine.substring(7));
						} else {
							switch (parseFloat(nine)) {
								case -1: mat.alpha = 0; break;
							}
						}
						obj.material = mat;
						obj.position = new BABYLON.Vector3(zero, one, two);
						obj.rotation = new BABYLON.Vector3(four, three, five);
						obj.scaling = new BABYLON.Vector3(six, seven, eight);
						platforms.push(obj);
						break;
				    case "C":
				        obj = BABYLON.MeshBuilder.CreateCylinder("C"+cones.length, { height: 0.5, diameterTop: 0, diameterBottom: 0.5, tessellation: 5 }, scene);
						obj.position = new BABYLON.Vector3(zero, one, two);
						obj.scaling.y = 1.2;
						cones.push(obj);
						if (typeof three == 'undefined') {
							
						} else if (three.length == 6) {
							mat.diffuseColor = new BABYLON.Color3.FromHexString("#"+three);
						} else if (three.length > 6) {
							mat.diffuseColor = new BABYLON.Color3.FromHexString("#"+three.substring(0,6));
							mat.alpha = parseFloat(three.substring(7));
						} else {
							switch (parseFloat(three)) {
								case -1: mat.alpha = 0; break;
							}
						}
						obj.material = mat;
						break;
				    case "E":
				        obj = BABYLON.MeshBuilder.CreateCylinder("E"+endings.length, { height: 2.0, diameter: 2.0, tessellation: 8 }, scene);
						obj.position = new BABYLON.Vector3(zero, one, two);
						endings.push(obj);
						break;
				    case "Y":
				        obj = BABYLON.MeshBuilder.CreateCylinder("Y"+cylinders.length, { height: 1.0, diameter: 1.0, tessellation: 12 }, scene);
						if (typeof nine == 'undefined') {
							
						} else if (nine.length == 6) {
							mat.diffuseColor = new BABYLON.Color3.FromHexString("#"+nine);
						} else if (nine.length > 6) {
							mat.diffuseColor = new BABYLON.Color3.FromHexString("#"+nine.substring(0,6));
							mat.alpha = parseFloat(nine.substring(7));
						} else {
							switch (parseFloat(nine)) {
								case -1: mat.alpha = 0; break;
							}
						}
						obj.material = mat;
						obj.position = new BABYLON.Vector3(zero, one, two);
						obj.rotation = new BABYLON.Vector3(four, three, five);
						obj.scaling = new BABYLON.Vector3(six, seven, eight);
						cylinders.push(obj);
						break;
					case "S":
						obj = BABYLON.MeshBuilder.CreateSphere("S"+spheres.length, { segments: 10, diameter: 1.0 }, scene);
						if (typeof four == 'undefined') {
							
						} else if (four.length == 6) {
							mat.diffuseColor = new BABYLON.Color3.FromHexString("#"+four);
						} else if (four.length > 6) {
							mat.diffuseColor = new BABYLON.Color3.FromHexString("#"+four.substring(0,6));
							mat.alpha = parseFloat(four.substring(7));
						} else {
							switch (parseFloat(four)) {
								case -1: mat.alpha = 0; break;
							}
						}
						obj.material = mat;
						obj.position = new BABYLON.Vector3(zero, one, two);
						obj.scaling = new BABYLON.Vector3(three, three, three);
						spheres.push(obj);
						break;
				}
				return obj;
			}
        </script>
    </body>
</html>
